# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' This function performs PCA with cardinality constraints on the component weights.
#' Note: This function is fully written in C++, therefore no default parameter arguments are given, please check the example below for sensible default values.
#'
#'
#' @param X A data matrix of class 'matrix'
#' @param ncomp The number of components to estimate (an integer)
#' @param nzeros A vector of length ncomp containing the number of desired zeros in the columns of the component weight matrix W 
#' @param itr The maximum number of iterations (an integer)
#' @param Wstart A matrix of ncomp columns and nrow(X) rows with starting values for the component weight matrix W, if Wstart only contains zeros, a warm start is used: the first ncomp right singular vectors of X
#' @param nStarts The number of random starts the analysis should perform. The first start will be performed with the values given by Wstart. The consecutive starts will be Wstart plus a matrix with random uniform values times the current start number (the first start has index zero). The default value is 1.
#' @param tol The convergence is determined by comparing the loss function value after each iteration, if the difference is smaller than tol, the analysis is converged. The default value is 10e-8
#' @param printLoss A boolean: TRUE will print the lossfunction value each 10th iteration.
#' @return A list containing: \cr
#' \code{W} A matrix containing the component weights \cr
#' \code{P} A matrix containing the loadings \cr
#' \code{loss} A numeric variable ccontaining the minumn loss function value of all the nStarts starts \cr
#' \code{converged} A boolean containing \code{TRUE} if converged \code{FALSE} if not converged.
#' @export
#' @examples
#'
#' I <- 100
#' J <- 50 
#' ncomp <- 3
#' X <- matrix(rnorm(I*J), I, J)
#' 
#' ccpca(X = X, ncomp = ncomp,  nzeros = c(10, 20, 30), itr = 100000, 
#'      Wstart = matrix(0, J, ncomp), nStarts = 1, tol = 10^-8, printLoss = TRUE)
ccpca <- function(X, ncomp, nzeros, itr, Wstart, nStarts = 1L, tol = 10e-8, printLoss = TRUE) {
    .Call(`_sparseWeightBasedPCA_ccpca`, X, ncomp, nzeros, itr, Wstart, nStarts, tol, printLoss)
}

#' This function performs PCA/SCA with and/or: ridge, lasso, grouplasso, elitistlasso regularization. This function allows for constraining certain weights to zero.
#' 
#'  
#' @param X A data matrix of class 'matrix'
#' @param ncomp The number of components to estimate (an integer)
#' @param ridge A vector containing a ridge parameter for each column of W seperately, to set the same ridge penalty for the component weights W, specify: ridge = rep(value, ncomp), value is a non-negative double
#' @param lasso A vector containing a ridge parameter for each column of W seperately, to set the same lasso penalty for the component weights W, specify: lasso = rep(value, ncomp), value is a non-negative double
#' @param grouplasso A vector containing a grouplasso parameter for each column of W seperately, to set the same grouplasso penalty for the component weights W, specify: grouplasso = rep(value, ncomp), value is a non-negative double
#' @param elitistlasso A vector containing a elitistlasso parameter for each column of W seperately, to set the same elitistlasso penalty for the component weights W, specify: elitistlasso = rep(value, ncomp), value is a non-negative double
#' @param groups A vector specifiying which columns of X belong to what block. Example: c(10, 100, 1000). The first 10 variables belong to the first block, the 100 variables after that belong to the second block etc.
#' @param constraints A matrix of the same dimensions as the component weights matrix W (ncol(X) x ncomp). A zero entry corresponds in constraints corresponds to an element in the same location in W that needs to be constraint to zero. A non-zero entry corresponds to an element in the same location in W that needs to be estimated.
#' @param itr The maximum number of iterations (a positive integer)
#' @param Wstart A matrix of ncomp columns and nrow(X) rows with starting values for the component weight matrix W, if Wstart only contains zeros, a warm start is used: the first ncomp right singular vectors of X
#' @param tol The convergence is determined by comparing the loss function value after each iteration, if the difference is smaller than tol, the analysis is converged. Default value is 10e-8
#' @param nStarts The number of random starts the analysis should perform. The first start will be performed with the values given by Wstart. The consecutive starts will be Wstart plus a matrix with random uniform values times the current start number (the first start has index zero).
#' @param printLoss A boolean: TRUE will print the lossfunction value each 1000 iteration.
#' @param coorDes A boolean with the default FALSE. If coorDes is FALSE the estimation of the majorizing function to estimate the component weights W conditional on the loadings P will be found using matrix inverses which can be slow. If set to true the marjozing function will be optimized (or partially optimized) using coordinate descent, in many cases coordinate descent will be faster
#' @param coorDesItr An integer specifying the maximum number of iterations for the coordinate descent algorithm, the default is set to 1. You do not have to run this algorithm until convergence before alternating back the the estimation of the loadings. The tolerance for this algorithm is hardcoded and set to 10^-8. 
#' @return A list containing: \cr
#' \code{W} A matrix containing the component weights \cr
#' \code{P} A matrix containing the loadings \cr
#' \code{loss} A numeric variable ccontaining the minumn loss function value of all the nStarts starts \cr
#' \code{converged} A boolean containing \code{TRUE} if converged \code{FALSE} if not converged.
#' @export
#' @examples
#'
#' J <- 30
#' X <- matrix(rnorm(100*J), 100, J)
#' ncomp <- 3
#' 
#' #An example of sparse SCA with ridge, lasso, and grouplasso regularization, with 2 groups, no constraints, and a "warm" start
#' mmsca(X = X, 
#'        ncomp = ncomp, 
#'        ridge = rep(10e-8, ncomp),
#'        lasso = rep(1, ncomp),
#'        grouplasso = rep(1, ncomp),
#'        elitistlasso = rep(0, ncomp),
#'        groups = c(J/2, J/2), 
#'        constraints = matrix(1, J, ncomp), 
#'        itr = 1000000, 
#'        Wstart = matrix(0, J, ncomp))
#'
mmsca <- function(X, ncomp, ridge, lasso, grouplasso, elitistlasso, groups, constraints, itr, Wstart, tol = 10e-8, nStarts = 1L, printLoss = TRUE, coorDes = FALSE, coorDesItr = 1L) {
    .Call(`_sparseWeightBasedPCA_mmsca`, X, ncomp, ridge, lasso, grouplasso, elitistlasso, groups, constraints, itr, Wstart, tol, nStarts, printLoss, coorDes, coorDesItr)
}

#' This function performs sparse PCA with constraints on the component weights and/or ridge and lasso regularization.
#' 
#' @param X A data matrix of class 'matrix'
#' @param ncomp The number of components to estimate (an integer)
#' @param ridge A numeric value containing the ridge parameter for the component weight matrix W
#' @param lasso A vector containing a ridge parameter for each column of W seperately, to set the same lasso penalty for the component weights W, specify: lasso = rep(value, ncomp)
#' @param constraints A matrix of the same dimensions as the component weights matrix W (ncol(X) x ncomp). A zero entry corresponds in constraints corresponds to an element in the same location in W that needs to be constraint to zero. A non-zero entry corresponds to an element in the same location in W that needs to be estimated.
#' @param itr The maximum number of iterations (an integer)
#' @param Wstart A matrix of ncomp columns and nrow(X) rows with starting values for the component weight matrix W, if Wstart only contains zeros, a warm start is used: the first ncomp right singular vectors of X
#' @param tol The convergence is determined by comparing the loss function value after each iteration, if the difference is smaller than tol, the analysis is converged. The default value is 10e-8.
#' @param nStarts The number of random starts the analysis should perform. The first start will be performed with the values given by Wstart. The consecutive starts will be Wstart plus a matrix with random uniform values times the current start number (the first start has index zero).
#' @param printLoss A boolean: TRUE will print the lossfunction value each 10th iteration.
#' @return A list containing: \cr
#' \code{W} A matrix containing the component weights \cr
#' \code{P} A matrix containing the loadings \cr
#' \code{loss} A numeric variable ccontaining the minumn loss function value of all the nStarts starts \cr
#' \code{converged} A boolean containing \code{TRUE} if converged \code{FALSE} if not converged. 
#' @export
#' @examples
#'
#' J <- 30
#' X <- matrix(rnorm(100*J), 100, J)
#' ncomp <- 3 
#' constraints <- matrix(1, J, ncomp) #no constraints 
#' 
#' scads(X, ncomp = ncomp, ridge = 10e-8, lasso = rep(1, ncomp), 
#'         constraints = constraints, Wstart = matrix(0, ncomp, J))
#'         
#' @references
#' De Schipper, N. C., & Van Deun, K. (2018). Revealing the Joint Mechanisms in Traditional Data Linked With Big 					Data. Zeitschrift Für Psychologie, 226(4), 212–231. doi:10.1027/2151-2604/a000341
scads <- function(X, ncomp, ridge, lasso, constraints, itr, Wstart, tol = 10e-8, nStarts = 1L, printLoss = TRUE) {
    .Call(`_sparseWeightBasedPCA_scads`, X, ncomp, ridge, lasso, constraints, itr, Wstart, tol, nStarts, printLoss)
}

